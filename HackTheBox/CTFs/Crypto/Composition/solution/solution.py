from Crypto.Util.number import *
from ecc import crt, EllipticCurve, Point
from hashlib import md5
from Crypto.Cipher import AES

def next_prime(num):
    if num % 2 == 0:
        num += 1
    else:
        num += 2
    while not isPrime(num):
        num += 2
    return num

q = 107278184747634701700946392111836744315702481323569962594843605164977794498807
p = 107278184747634701700946392111836744315702481323569962594843605164977794489147
n = p * q
assert (p < q)

x=5508983209527975548550585676716095056891986060299897850076467266440963129189962356129156126478319154469892234460763336815556418453926190671315931126013174
y=4584770413276521675772328975255407936886405573620806198419665822168179869816470891739795723864215114542450500604761246124799543529684175674193341820212484

xx=3226253864140318314992843188045096483768261637725900409330118686357450106017616191469079239076154809355782743505509237084237625038367838765695294366341438
yy=7019366440029220583093783473635971841967732007511176621801741471609642262833387811997345239978637383474634582765734139255540271981538930919789728479139512

a = inverse(x - xx, n) * ((y ** 2 - x ** 3) - (yy ** 2 - xx ** 3)) % n
b = (y ** 2 - x ** 3 - a * x) % n

print(a)
print(b)
print((y ** 2 - (x ** 3 + a * x + b)) % n)
print((yy ** 2 - (xx ** 3 + a * xx + b)) % n)

bits = 512
e = next_prime(p >> (bits // 4))
phip = 13409773093454337712618299013979593039463609972672170451564016101898473737637
phiq = 35759394915878233900315464037278914771976539133649605170216418756737016027987
dp = inverse(e, phip)
dq = inverse(e, phiq)
dn = crt([dp, phip], [dq, phiq])
EC = EllipticCurve(a, b, n)
P = Point(x, y)
G = EC.multiply(P, dn)
PP = EC.multiply(G, e)
print(PP)
print(P)

IV = bytes.fromhex('4f5d8a65782617f1a499857d9b3cc596')
c = 'f335506d8f1ed5a2c3a87ca77fd8b02315cbdc8cb74a12cd009b767c03c59723fe908e6b73531a4e867f5ddb286513af67cdae250142958e246de897127f00aa'
c = bytes.fromhex(c)
key = md5(str(G.x).encode()).digest()

cipher = AES.new(key, AES.MODE_CBC, IV)
m = cipher.decrypt(c)
print(m)